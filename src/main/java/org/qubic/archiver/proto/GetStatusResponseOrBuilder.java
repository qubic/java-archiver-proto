// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: archive.proto

package org.qubic.archiver.proto;

public interface GetStatusResponseOrBuilder extends
    // @@protoc_insertion_point(interface_extends:qubic.archiver.archive.pb.GetStatusResponse)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <code>.qubic.archiver.archive.pb.ProcessedTick last_processed_tick = 1;</code>
   * @return Whether the lastProcessedTick field is set.
   */
  boolean hasLastProcessedTick();
  /**
   * <code>.qubic.archiver.archive.pb.ProcessedTick last_processed_tick = 1;</code>
   * @return The lastProcessedTick.
   */
  org.qubic.archiver.proto.ProcessedTick getLastProcessedTick();
  /**
   * <code>.qubic.archiver.archive.pb.ProcessedTick last_processed_tick = 1;</code>
   */
  org.qubic.archiver.proto.ProcessedTickOrBuilder getLastProcessedTickOrBuilder();

  /**
   * <code>map&lt;uint32, uint32&gt; last_processed_ticks_per_epoch = 2;</code>
   */
  int getLastProcessedTicksPerEpochCount();
  /**
   * <code>map&lt;uint32, uint32&gt; last_processed_ticks_per_epoch = 2;</code>
   */
  boolean containsLastProcessedTicksPerEpoch(
      int key);
  /**
   * Use {@link #getLastProcessedTicksPerEpochMap()} instead.
   */
  @java.lang.Deprecated
  java.util.Map<java.lang.Integer, java.lang.Integer>
  getLastProcessedTicksPerEpoch();
  /**
   * <code>map&lt;uint32, uint32&gt; last_processed_ticks_per_epoch = 2;</code>
   */
  java.util.Map<java.lang.Integer, java.lang.Integer>
  getLastProcessedTicksPerEpochMap();
  /**
   * <code>map&lt;uint32, uint32&gt; last_processed_ticks_per_epoch = 2;</code>
   */

  int getLastProcessedTicksPerEpochOrDefault(
      int key,
      int defaultValue);
  /**
   * <code>map&lt;uint32, uint32&gt; last_processed_ticks_per_epoch = 2;</code>
   */

  int getLastProcessedTicksPerEpochOrThrow(
      int key);

  /**
   * <code>repeated .qubic.archiver.archive.pb.SkippedTicksInterval skipped_ticks = 3;</code>
   */
  java.util.List<org.qubic.archiver.proto.SkippedTicksInterval> 
      getSkippedTicksList();
  /**
   * <code>repeated .qubic.archiver.archive.pb.SkippedTicksInterval skipped_ticks = 3;</code>
   */
  org.qubic.archiver.proto.SkippedTicksInterval getSkippedTicks(int index);
  /**
   * <code>repeated .qubic.archiver.archive.pb.SkippedTicksInterval skipped_ticks = 3;</code>
   */
  int getSkippedTicksCount();
  /**
   * <code>repeated .qubic.archiver.archive.pb.SkippedTicksInterval skipped_ticks = 3;</code>
   */
  java.util.List<? extends org.qubic.archiver.proto.SkippedTicksIntervalOrBuilder> 
      getSkippedTicksOrBuilderList();
  /**
   * <code>repeated .qubic.archiver.archive.pb.SkippedTicksInterval skipped_ticks = 3;</code>
   */
  org.qubic.archiver.proto.SkippedTicksIntervalOrBuilder getSkippedTicksOrBuilder(
      int index);

  /**
   * <code>repeated .qubic.archiver.archive.pb.ProcessedTickIntervalsPerEpoch processed_tick_intervals_per_epoch = 4;</code>
   */
  java.util.List<org.qubic.archiver.proto.ProcessedTickIntervalsPerEpoch> 
      getProcessedTickIntervalsPerEpochList();
  /**
   * <code>repeated .qubic.archiver.archive.pb.ProcessedTickIntervalsPerEpoch processed_tick_intervals_per_epoch = 4;</code>
   */
  org.qubic.archiver.proto.ProcessedTickIntervalsPerEpoch getProcessedTickIntervalsPerEpoch(int index);
  /**
   * <code>repeated .qubic.archiver.archive.pb.ProcessedTickIntervalsPerEpoch processed_tick_intervals_per_epoch = 4;</code>
   */
  int getProcessedTickIntervalsPerEpochCount();
  /**
   * <code>repeated .qubic.archiver.archive.pb.ProcessedTickIntervalsPerEpoch processed_tick_intervals_per_epoch = 4;</code>
   */
  java.util.List<? extends org.qubic.archiver.proto.ProcessedTickIntervalsPerEpochOrBuilder> 
      getProcessedTickIntervalsPerEpochOrBuilderList();
  /**
   * <code>repeated .qubic.archiver.archive.pb.ProcessedTickIntervalsPerEpoch processed_tick_intervals_per_epoch = 4;</code>
   */
  org.qubic.archiver.proto.ProcessedTickIntervalsPerEpochOrBuilder getProcessedTickIntervalsPerEpochOrBuilder(
      int index);

  /**
   * <code>map&lt;uint32, uint32&gt; empty_ticks_per_epoch = 5;</code>
   */
  int getEmptyTicksPerEpochCount();
  /**
   * <code>map&lt;uint32, uint32&gt; empty_ticks_per_epoch = 5;</code>
   */
  boolean containsEmptyTicksPerEpoch(
      int key);
  /**
   * Use {@link #getEmptyTicksPerEpochMap()} instead.
   */
  @java.lang.Deprecated
  java.util.Map<java.lang.Integer, java.lang.Integer>
  getEmptyTicksPerEpoch();
  /**
   * <code>map&lt;uint32, uint32&gt; empty_ticks_per_epoch = 5;</code>
   */
  java.util.Map<java.lang.Integer, java.lang.Integer>
  getEmptyTicksPerEpochMap();
  /**
   * <code>map&lt;uint32, uint32&gt; empty_ticks_per_epoch = 5;</code>
   */

  int getEmptyTicksPerEpochOrDefault(
      int key,
      int defaultValue);
  /**
   * <code>map&lt;uint32, uint32&gt; empty_ticks_per_epoch = 5;</code>
   */

  int getEmptyTicksPerEpochOrThrow(
      int key);
}
